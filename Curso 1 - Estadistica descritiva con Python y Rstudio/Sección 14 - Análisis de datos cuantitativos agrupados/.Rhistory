#Si la función es negativa y tiene decimales redondea hacia abajo
n=length(cw)
k1 = ceiling(sqrt(n)) #Función ceiling cuando el valor es positivivo y tiene decimales redondea hacia arriba
#Si la función es negativa y tiene decimales redondea hacia abajo
k1
k2 = ceiling(1+log(n,2))
k2
As= 3.5*sd(cw)*n^(-1/3) #Amplitud teorica
k3 = ceiling(diff(range(cw))/As)
k3
Afd= 2*(quantile(cw,
0.75,
names = FALSE)-
quantile(cw,
0.25,
names = FALSE)*n^(-1/3))
k4= ceiling(diff(range(cw))/Afd)
k4
Afd= 2*(quantile(cw,
0.75,
names = FALSE)-
quantile(cw,
0.25,
names = FALSE))*n^(-1/3)
k4= ceiling(diff(range(cw))/Afd)
k4
Afd= 2*(quantile(cw,
0.75,
names = FALSE)-
quantile(cw,
0.25,
names = FALSE)
)*n^(-1/3)
k4= ceiling(diff(range(cw))/Afd)
k4
k2 #Resultado de la regla de Sturges
nclass.Sturges(cw) #Reglad e Sturges
print(' ')
k3 #Resultado de la regla de Scott
nclass.scott(cw) #Regla de Scott
print(' ')
k4 #Resultado de la regla de Freedman
nclass.FD(cw) #Regla de freedman
temp = c(10,1,1,1,1,1,1,2,1,1,1,1,1,1,1,3,10)
diff(temp)
A = diff(range(cw))/10
A
L1 = min(cw)-2*0.1
L1
L2 = L1 + A
L3 = L2 + A
L4 = L3 + A
L5 = L4 + A
L6 = L5 + A
L7 = L6 + A
L8 = L7 + A
L9 = L8 + A
L10 = L9 + A
L11 = L10 + A
L = c(L1,L2,L3,L4,L5,L6,L7,L8,L9,L10,L11)
L
Am = diff(range(cw))/10
Am #Redondeo a 1.3
A <- 1.3
L1 = min(cw)-2*0.1
#Donde 0.1 es nuestrea precisión (décimas de unidad, en este caso)
L1
L2 = L1 + A
L3 = L2 + A
L4 = L3 + A
L5 = L4 + A
L6 = L5 + A
L7 = L6 + A
L8 = L7 + A
L9 = L8 + A
L10 = L9 + A
L11 = L10 + A
L = c(L1,L2,L3,L4,L5,L6,L7,L8,L9,L10,L11)
L
cw = crab$width
A = 1.3
L1 = min(cw)-2*0.1
n = 0
for (i in (L1:10))
for (i in range(10))
cw = crab$width
A = 1.3
L1 = min(cw)-2*0.1
n = 0
for (i in range(10))
L[n] = L1+A
print(L)
L2 = L1 + A
L3 = L2 + A
L4 = L3 + A
L5 = L4 + A
L6 = L5 + A
L7 = L6 + A
L8 = L7 + A
L9 = L8 + A
L10 = L9 + A
L11 = L10 + A
L = c(L1,L2,L3,L4,L5,L6,L7,L8,L9,L10,L11)
L
# Otra forma de hacerlo:
L1 = min(cw)-2*0.1
n = 0
for (i in range(10))
Lf[n] = L1+A
L2 = L1 + A
L3 = L2 + A
L4 = L3 + A
L5 = L4 + A
L6 = L5 + A
L7 = L6 + A
L8 = L7 + A
L9 = L8 + A
L10 = L9 + A
L11 = L10 + A
L = c(L1,L2,L3,L4,L5,L6,L7,L8,L9,L10,L11)
L
# Otra forma de hacerlo:
Lf = 0
L1 = min(cw)-2*0.1
n = 0
for (i in range(10))
Lf[n] = L1+A
print(Lf)
L2 = L1 + A
L3 = L2 + A
L4 = L3 + A
L5 = L4 + A
L6 = L5 + A
L7 = L6 + A
L8 = L7 + A
L9 = L8 + A
L10 = L9 + A
L11 = L10 + A
L = c(L1,L2,L3,L4,L5,L6,L7,L8,L9,L10,L11)
L
# Otra forma de hacerlo:
Lf = 1
L1 = min(cw)-2*0.1
n = 0
for (i in range(10))
Lf[n] = L1+A
print(Lf)
L2 = L1 + A
L3 = L2 + A
L4 = L3 + A
L5 = L4 + A
L6 = L5 + A
L7 = L6 + A
L8 = L7 + A
L9 = L8 + A
L10 = L9 + A
L11 = L10 + A
L = c(L1,L2,L3,L4,L5,L6,L7,L8,L9,L10,L11)
L
# Otra forma de hacerlo:
L1 = min(cw)-2*0.1
n = 0
for (i in range(10)){
Lf[n] = L1+A}
print(Lf)
L2 = L1 + A
weight = c(55.2,54.0,55.2,53.7,60.2,54.6,55.1,51.2,53.2,54.8,52.3,56.9,57.0,55.0,53.5,50.9,55.1,53.6,61.2,59.5,50.3,52.7,60.0)
barplot(table(weight), cex.names = 0.40)
library(RCurl)
df <- getURL("https://raw.githubusercontent.com/argeus47/r-basic/master/data/datacrab.txt", ssl.verifypeer = FALSE)
crab <- read.csv(textConnection(df),
# stringsAsFactors=FALSE,
header = T, #Para que los nombres de la                                    cabecera aparescan
sep = "", #Indica las separaciones de una columna con otra en el fichero, da error si el separador fue introducido equivocadamente
dec = ".") #Puedo quitar el separador decimal
crab <- crab[, #Para que aparezcan todas las filas
-1] #Para eliminar la primera columna que es solo un identificador para cada fila.
# A continuación,  definimos la variable CW que contiene los datos de la variable WIDHT
cw = crab$width #Variable numerica con decimales
n=length(cw)
k1 = ceiling(sqrt(n)) #Función ceiling cuando el valor es positivivo y tiene decimales redondea hacia arriba
#Si la función es negativa y tiene decimales redondea hacia abajo
k1 #Segun la regla de la raiz cuadrada devemos tomar 14 intervalos
k2 = ceiling(1+log(n,2))
k2 #Segun la regla de sturges devemos tomar 9 intervalos
As= 3.5*sd(cw)*n^(-1/3) #Amplitud teorica
k3 = ceiling(diff(range(cw))/As)
k3 #Segun la regla de Scott devemos tomar 10 intervalos
k2 #Resultado de la regla de Sturges
nclass.Sturges(cw) #Reglad e Sturges
print(' ')
k3 #Resultado de la regla de Scott
nclass.scott(cw) #Regla de Scott
print(' ')
k4 #Resultado de la regla de Freedman
Afd= 2*(quantile(cw,
0.75,
names = FALSE)-
quantile(cw,
0.25,
names = FALSE)
)*n^(-1/3)
k4= ceiling(diff(range(cw))/Afd)
k4 #Segun la regla de Freedman devemos tomar 13 intervalos
k2 #Resultado de la regla de Sturges
nclass.Sturges(cw) #Reglad e Sturges
print(' ')
k3 #Resultado de la regla de Scott
nclass.scott(cw) #Regla de Scott
print(' ')
k4 #Resultado de la regla de Freedman
nclass.FD(cw) #Regla de freedman
#Es posible que tenga una pequeña variación en el resultado de calculo a mano en comparación al calculo en R pero es 1 digito arriba ou un digito abajo
Am = diff(range(cw))/10
Am #Redondeo a 1.3
A <- 1.3
L1 = min(cw)-2*0.1
#Donde 0.1 es nuestrea precisión (décimas de unidad, en este caso)
L1
L2 = L1 + A
L3 = L2 + A
L4 = L3 + A
L5 = L4 + A
L6 = L5 + A
L7 = L6 + A
L8 = L7 + A
L9 = L8 + A
L10 = L9 + A
L11 = L10 + A
#L = c(L1,L2,L3,L4,L5,L6,L7,L8,L9,L10,L11)
#L
# Otra forma de hacerlo:
L1 = min(cw)-2*0.1
n = 0
for (i in range(10)){
Lf[n] = L1+A}
i <- NULL #Es el indice
aux <- NULL #Una variable auxiliar, va a asumir un resultado
r <- NULL # Vector resultante que va a acumular resultados
#que se van obteniendo de la variable aux
#Para i asumiendo el valor 1,2 y 3
for (i in 1:3){
#La variable aux va asumir 10*1, 10*2, 10*3
aux <- 10*^i; ; #Si lo dejo aqui la variable aux no se
#Va a guardar en ningun lugar por lo que
#Creamos la variable r para que guarde la variable aux
r<-c(r,aux)
}
aux
aux
for (i in 1:3){
#La variable aux va asumir 10*1, 10*2, 10*3
aux <- 10*^i; ; #Si lo dejo aqui la variable aux no se
#Va a guardar en ningun lugar por lo que
#Creamos la variable r para que guarde la variable aux
r<-c(r,aux)
}
for (i in 1:3){
#La variable aux va asumir 10*1, 10*2, 10*3
aux <- 10*^i; ; #Si lo dejo aqui la variable aux no se
#Va a guardar en ningun lugar por lo que
#Creamos la variable r para que guarde la variable aux
r<-c(r,aux)}
aux
for (i in 1:3){
#La variable aux va asumir 10*1, 10*2, 10*3
aux <- 10*^i;  #Si lo dejo aqui la variable aux no se
#Va a guardar en ningun lugar por lo que
#Creamos la variable r para que guarde la variable aux
r<-c(r,aux)}
aux
for (i in 1:3){
#La variable aux va asumir 10*1, 10*2, 10*3
aux <- 10*^i;  #Si lo dejo aqui la variable aux no se
#Va a guardar en ningun lugar por lo que
#Creamos la variable r para que guarde la variable aux
r<-c(r,aux)}
aux
aux
r
for (i in 1:3){
#La variable aux va asumir 10*1, 10*2, 10*3
aux <- 10*^i;  #Si lo dejo aqui la variable aux no se
#Va a guardar en ningun lugar por lo que
#Creamos la variable r para que guarde la variable aux
r<-c(r,aux)}
r
r
aux
r
i <- NULL #Es el indice
aux <- NULL #Una variable auxiliar, va a asumir un resultado
r <- NULL # Vector resultante que va a acumular resultados
#que se van obteniendo de la variable aux
#Para i asumiendo el valor 1,2 y 3
for (i in 1:3){
#La variable aux va asumir 10*1, 10*2, 10*3
aux <- 10^i;  #Si lo dejo aqui la variable aux no se
#Va a guardar en ningun lugar por lo que
#Creamos la variable r para que guarde la variable aux
r<-c(r,aux)}
aux
r
i <- NULL #Es el indice
aux <- NULL #Una variable auxiliar, va a asumir un resultado
r <- NULL # Vector resultante que va a acumular resultados
#que se van obteniendo de la variable aux
b <- 10
#Para i asumiendo el valor 1,2 y 3
for (i in 0:3){
#La variable aux va asumir 10*1, 10*2, 10*3
aux <- data.frame(base = b,
exp = i,
expporlogaritmo = log(10^i, base = b),
potencia = 10^i)  #Si lo dejo aqui la variable aux no se Va a guardar en ningun lugar por lo que
#Creamos la variable r para que guarde la variable aux
r<- rbind(r, #El primer valor es nulo
aux)} #Se combina con el valor aux entonces el 1er valor
#Se considera el 1ro que  da aux
aux
r
knitr::opts_chunk$set(echo = TRUE)
library(RCurl)
df <- getURL("https://raw.githubusercontent.com/argeus47/r-basic/master/data/datacrab.txt", ssl.verifypeer = FALSE)
crab <- read.csv(textConnection(df),
# stringsAsFactors=FALSE,
header = T, #Para que los nombres de la                                    cabecera aparescan
sep = "", #Indica las separaciones de una columna con otra en el fichero, da error si el separador fue introducido equivocadamente
dec = ".") #Puedo quitar el separador decimal
crab <- crab[, #Para que aparezcan todas las filas
-1] #Para eliminar la primera columna que es solo un identificador para cada fila.
# A continuación,  definimos la variable CW que contiene los datos de la variable WIDHT
cw = crab$width #Variable numerica con decimales
n=length(cw)
k1 = ceiling(sqrt(n)) #Función ceiling cuando el valor es positivivo y tiene decimales redondea hacia arriba
#Si la función es negativa y tiene decimales redondea hacia abajo
k1 #Segun la regla de la raiz cuadrada devemos tomar 14 intervalos
n=length(cw)
k1 = ceiling(sqrt(n)) #Función ceiling cuando el valor es positivivo y tiene decimales redondea hacia arriba
#Si la función es negativa y tiene decimales redondea hacia abajo
k1 #Segun la regla de la raiz cuadrada devemos tomar 14 intervalos
k2 = ceiling(1+log(n,2))
k2 #Segun la regla de sturges devemos tomar 9 intervalos
As= 3.5*sd(cw)*n^(-1/3) #Amplitud teorica
k3 = ceiling(diff(range(cw))/As)
k3 #Segun la regla de Scott devemos tomar 10 intervalos
Afd= 2*(quantile(cw,
0.75,
names = FALSE)-
quantile(cw,
0.25,
names = FALSE)
)*n^(-1/3)
k4= ceiling(diff(range(cw))/Afd)
k4 #Segun la regla de Freedman devemos tomar 13 intervalos
k2 #Resultado de la regla de Sturges
nclass.Sturges(cw) #Reglad e Sturges
print(' ')
k3 #Resultado de la regla de Scott
nclass.scott(cw) #Regla de Scott
print(' ')
k4 #Resultado de la regla de Freedman
nclass.FD(cw) #Regla de freedman
#Es posible que tenga una pequeña variación en el resultado de calculo a mano en comparación al calculo en R pero es 1 digito arriba ou un digito abajo
Am = diff(range(cw))/10
Am #Redondeo a 1.3
A <- 1.3
L1 = min(cw)-2*0.1
#Donde 0.1 es nuestrea precisión (décimas de unidad, en este caso)
L1
L2 = L1 + A
L3 = L2 + A
L4 = L3 + A
L5 = L4 + A
L6 = L5 + A
L7 = L6 + A
L8 = L7 + A
L9 = L8 + A
L10 = L9 + A
L11 = L10 + A
L = c(L1,L2,L3,L4,L5,L6,L7,L8,L9,L10,L11)
L
L1 = min(cw)-1/2*0.1
#Donde 0.1 es nuestrea precisión (décimas de unidad, en este caso)
L1
L2 = L1 + A
L3 = L2 + A
L4 = L3 + A
L5 = L4 + A
L6 = L5 + A
L7 = L6 + A
L8 = L7 + A
L9 = L8 + A
L10 = L9 + A
L11 = L10 + A
L = c(L1,L2,L3,L4,L5,L6,L7,L8,L9,L10,L11)
L
L2 = L1 + A
L3 = L2 + A
L4 = L3 + A
L5 = L4 + A
L6 = L5 + A
L7 = L6 + A
L8 = L7 + A
L9 = L8 + A
L10 = L9 + A
L11 = L10 + A
L = c(L1,L2,L3,L4,L5,L6,L7,L8,L9,L10,L11)
L
print(' ')
# Calculando automaticamente todos los valores de L
L2 = L1 + A*(0:10)
L2
X1= (L[1]+L[2])/2
X1
X2 = X1 + A
X3 = X2 + A
X4 = X3 + A
X5 = X4 + A
X6 = X5 + A
X7 = X6 + A
X8 = X7 + A
X9 = X8 + A
X10 = X9 + A
X = C(X1,X2,X3,X4,X5,X6,X7,X8,X9,X10)
X2 = X1 + A
X3 = X2 + A
X4 = X3 + A
X5 = X4 + A
X6 = X5 + A
X7 = X6 + A
X8 = X7 + A
X9 = X8 + A
X10 = X9 + A
X = c(X1,X2,X3,X4,X5,X6,X7,X8,X9,X10)
X
print(' ')
# Calculando automaticamente todos los valores de X
X2 = X1 + A*(0:10)
X2
knitr::opts_chunk$set(echo = TRUE)
X1 = 21.6
A = 1.3
X2 = X1 + A*(0:10)
X2
X2 = X1 + A
X3 = X2 + A
X4 = X3 + A
X5 = X4 + A
X6 = X5 + A
X7 = X6 + A
X8 = X7 + A
X9 = X8 + A
X10 = X9 + A
X = c(X1,X2,X3,X4,X5,X6,X7,X8,X9,X10)
X
print(' ')
# Calculando automaticamente todos los valores de X
X2 = X1 + A*(0:10)
X2
print(' ')
# o también, como punto medio del intervalo
X3 = (L[1:length(L)-1] + L[2:length(L)])/2
X3
X2 = X1 + A
X3 = X2 + A
X4 = X3 + A
X5 = X4 + A
X6 = X5 + A
X7 = X6 + A
X8 = X7 + A
X9 = X8 + A
X10 = X9 + A
X = c(X1,X2,X3,X4,X5,X6,X7,X8,X9,X10)
X
print(' ')
# Calculando automaticamente todos los valores de X
X2 = X1 + A*(0:9)
X2
print(' ')
# o también, como punto medio del intervalo
X3 = (L[1:length(L)-1] + L[2:length(L)])/2
X3
knitr::opts_chunk$set(echo = TRUE)
As= 3.5*sd(cw)*n^(-1/3) #Amplitud teorica
library(RCurl)
df <- getURL("https://raw.githubusercontent.com/argeus47/r-basic/master/data/datacrab.txt", ssl.verifypeer = FALSE)
crab <- read.csv(textConnection(df),
# stringsAsFactors=FALSE,
header = T, #Para que los nombres de la                                    cabecera aparescan
sep = "", #Indica las separaciones de una columna con otra en el fichero, da error si el separador fue introducido equivocadamente
dec = ".") #Puedo quitar el separador decimal
crab <- crab[, #Para que aparezcan todas las filas
-1] #Para eliminar la primera columna que es solo un identificador para cada fila.
# A continuación,  definimos la variable CW que contiene los datos de la variable WIDHT
cw = crab$width #Variable numerica con decimales
n=length(cw)
k1 = ceiling(sqrt(n)) #Función ceiling cuando el valor es positivivo y tiene decimales redondea hacia arriba
#Si la función es negativa y tiene decimales redondea hacia abajo
k1 #Segun la regla de la raiz cuadrada devemos tomar 14 intervalos
As= 3.5*sd(cw)*n^(-1/3) #Amplitud teorica
As
k3 = ceiling(diff(range(cw))/As)
k3 #Segun la regla de Scott devemos tomar 10 intervalos
?diff
As= 3.5*sd(cw)*n^(-1/3) #Amplitud teorica
As
k3 = ceiling(diff(range(cw))/As)
k3 #Segun la regla de Scott devemos tomar 10 intervalos
range(cw)
?range
reticulate::repl_python()
